{
  function makeAstNode(type, value, location) {
    return {
      type,
      value,
      location
    };
  }

  function makeKeyValue(key, value, location) {
    return {
      key,
      value,
      location
    };
  }

  function makeObject(pairs) {
    const obj = {};
    for (const pair of pairs) {
      if (pair) {
        obj[pair.key] = pair.value;
      }
    }
    return obj;
  }

  function makeArray(items) {
    return items.filter(item => item !== null);
  }
}

// Starting rule for Terragrunt configuration
Start
  = _ statements:Statement* _ { 
    return makeAstNode('root', statements, location());
  }

// A statement can be either a block or an assignment
Statement
  = _ (Block / Assignment) _

// Block definition (e.g., terraform {}, include {}, etc.)
Block
  = start:_ name:Identifier _ "{" _ 
    pairs:(Pair*) 
    _ "}" _ {
      const blockLoc = location();
      const value = {};
      pairs.forEach(pair => {
        if (pair) {
          value[pair.key] = pair.value;
        }
      });
      return makeKeyValue(name, value, blockLoc);
    }

// Assignment (e.g., inputs = {...})
Assignment
  = _ key:Identifier _ "=" _ value:Value _ {
    return makeKeyValue(key, value, location());
  }

// Key-value pair inside blocks
Pair
  = _ key:Identifier _ "=" _ value:Value _ {
    return makeKeyValue(key, value, location());
  }

// Values can be strings, numbers, booleans, arrays, objects
Value
  = start:_ val:(StringLiteral / Number / Boolean / Array / Object / Expression) end:_ {
    return val;
  }

// Object literal
Object
  = "{" _ pairs:Pair* _ "}" {
    const obj = {};
    pairs.forEach(pair => {
      if (pair) {
        obj[pair.key] = pair.value;
      }
    });
    return makeAstNode('object_lit', obj, location());
  }

// String literal with quotes
StringLiteral
  = '"' chars:StringChar* '"' {
    return makeAstNode('string_lit', chars.join(''), location());
  }
  / "'" chars:SingleQuoteChar* "'" {
    return makeAstNode('string_lit', chars.join(''), location());
  }

StringChar
  = [^"\\]
  / "\\" char:["\\/bfnrt] { return eval('"\\' + char + '"'); }

SingleQuoteChar
  = [^'\\]
  / "\\" char:. { return char; }

// Numbers
Number
  = minus:"-"? int:Integer frac:Fraction? exp:Exponent? {
    return makeAstNode('number_lit', 
      parseFloat(minus + int + frac + exp),
      location()
    );
  }

Integer
  = "0"
  / [1-9] [0-9]*

Fraction
  = "." [0-9]+

Exponent
  = [eE] [+-]? [0-9]+

// Boolean values
Boolean
  = "true" { return makeAstNode('boolean_lit', true, location()); }
  / "false" { return makeAstNode('boolean_lit', false, location()); }

// Arrays
Array
  = "[" _ items:(Value ( _ "," _ Value)*)? _ "]" {
    const values = items 
      ? makeArray([items[0]].concat(items[1].map(item => item[3])))
      : [];
    return makeAstNode('array_lit', values, location());
  }

// HCL/Terragrunt expressions (e.g., ${...}, get_terragrunt_dir())
Expression
  = "${" _ chars:ExpressionChar+ _ "}" { 
    return makeAstNode('interpolation', "${" + chars.join('') + "}", location());
  }
  / FunctionCall

ExpressionChar
  = [^}]

// Function calls
FunctionCall
  = name:Identifier _ "(" _ args:FunctionArgs? _ ")" {
    return makeAstNode(
      'function_call',
      `${name}(${args ? args.join(', ') : ''})`,
      location()
    );
  }

FunctionArgs
  = arg:Value rest:( _ "," _ Value)* {
    return [arg].concat(rest.map(r => r[3]));
  }

// Identifiers
Identifier
  = chars:IdentifierChar+ {
    return chars.join('');
  }

IdentifierChar
  = [a-zA-Z0-9_-]

// Whitespace and comments
_
  = (Whitespace / Comment)*

Whitespace
  = [ \t\n\r]

Comment
  = SingleLineComment
  / MultiLineComment

SingleLineComment
  = "//" [^\n]*
  / "#" [^\n]*

MultiLineComment
  = "/*" (!"*/" .)* "*/"