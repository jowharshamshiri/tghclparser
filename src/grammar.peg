{
  let debugEnabled = false;
  let heredocMarker = null;
  let nextId = 1;

  function debugLog(rule, text, pos, context = {}) {
    if (debugEnabled) {
      let preview = '';
      // Check if text is a string
      if (typeof text == 'string') {
        preview = text?.substring(Math.max(0, pos - 20), pos + 20)
          .replace(/\n/g, '\\n');
      } else {
        if (typeof text == 'function') {
          preview = text().substring(Math.max(0, pos - 20), pos + 20);
        } else {
          preview = '';
          console.log('text is not a function, it is a ' + typeof text);
        }
      }
      const positionMarker = 'â†’';
      const markerPos = Math.min(20, pos);

      const contextInfo = Object.entries(context)
        .map(([key, value]) => `${key}: ${JSON.stringify(value)}`)
        .join(', ');

      console.log(
        `[${rule}] at pos ${pos}\n` +
        `Context: ${contextInfo}\n` +
        `${preview.slice(0, markerPos)}${positionMarker}${preview.slice(markerPos)}\n` +
        `${' '.repeat(markerPos)}${positionMarker}\n`
      );
    }
  }

  function getNextId() {
    return nextId++;
  }

  function makeNode(type, value, location, children = []) {
    const node = {
      id: getNextId(),
      type,
      ...(value !== null && { value }),
      location,
      ...(children.length > 0 && { children })
    };

    if (debugEnabled) {
      console.log('Created Node:', JSON.stringify(node, null, 2));
    }

    return node;
  }

  function makeIdentifierNode(name, location) {
    return makeNode('identifier', name, location);
  }
}

Start = _ statements:Statement* _ {
  debugLog('Start', text, location().start.offset, { statementsCount: statements.length });
  return makeNode('root', null, location(), statements);
}

Statement = statement:(RootAssignment / Block) _ {
  return statement;
}

RootAssignment = _ name:RootAssignmentIdentifier _ "=" _ value:(RootValue / Boolean / StringLiteral) {
  return makeNode('assignment', name.value, location(), [name, value]);
}

RootValue = val:(
  Block / 
  RootObject / 
  Array / 
  TernaryExpression / 
  ComparisonExpression / 
  FunctionCall / 
  TypeConstraint /
  TypeConstructor /
  CollectionConstructor /
  Expression
) {
  return val;
}

Block = _ name:BlockIdentifier _ params:BlockParameter* _ metaArgs:MetaArguments? _ "{" _ items:BlockItems _ "}" {
  return makeNode('block', name.value, location(), [
    name, 
    ...params, 
    ...(metaArgs ? [metaArgs] : []),
    ...(items || [])
  ]);
}

BlockItems = items:(
  Pair /
  ParameterizedBlock /
  DynamicBlock /
  ValidationBlock /
  Block
)* {
  return items;
}

ParameterizedBlock = name:BlockIdentifier _ param:StringLiteral _ "{" _ items:BlockItems _ "}" {
  const paramNode = makeNode('parameter', param.value, param.location, [param]);
  return makeNode('block', name.value, location(), [name, paramNode, ...(items || [])]);
}

DynamicBlock = "dynamic" _ blockType:StringLiteral _ "{" _
  "for_each" _ "=" _ collection:Value _
  content:Block _
"}" {
  return makeNode('dynamic_block', blockType.value, location(), [
    makeNode('for_each', null, location(), [collection]),
    content
  ]);
}

BlockIdentifier = name:$([a-zA-Z_][a-zA-Z0-9_\-.*]*) {
  return makeNode('block_identifier', name, location());
}

BlockParameter = _ param:StringLiteral {
  return makeNode('parameter', param.value, location(), [param]);
}

RootAssignmentIdentifier
  = name:$([a-zA-Z_][a-zA-Z0-9_\-.]*) {
    return makeNode('root_assignment_identifier', name, location());
  }

Pair = key:AttributeIdentifier _ "=" _ value:Value {
  return makeNode('attribute', key.value, location(), [key, value]);
}

AttributeIdentifier
  = QuotedAttributeIdentifier / UnquotedAttributeIdentifier

QuotedAttributeIdentifier
  = str:StringLiteral {
    return makeNode('attribute_identifier', str.value, location(), [], { quoted: true });
  }

UnquotedAttributeIdentifier
  = name:$([a-zA-Z_][a-zA-Z0-9_\-.]*) {
    return makeNode('attribute_identifier', name, location(), [], { quoted: false });
  }

RootObject = "{" _ pairs:(Pair (_ ","? _ Pair)* (_ ",")?)? _ inherit:InheritanceExpression? _ "}" {
  const values = pairs ? [pairs[0], ...pairs[1].map(pair => pair[3])] : [];
  return makeNode('object', null, location(), [...values, ...(inherit ? [inherit] : [])]);
}

PrimaryExpression =
  StringLiteral /
  Number /
  Boolean /
  FunctionCall /
  Reference /
  "(" _ expr:Expression _ ")" { return expr; } /
  SimpleExpression

Value = val:(
  Expression /
  Array /
  Object /
  TypeConstructor /
  CollectionConstructor
) _ {
  return val;
}

Reference = !FunctionCall head:ReferenceIdentifier tail:("." ReferenceIdentifier)* {
  return makeNode('reference', head.value + tail.map(t => "." + t[1].value).join(''), location());
}

ReferenceIdentifier
  = name:$([a-zA-Z_][a-zA-Z0-9_\-.]*) {
    return makeNode('reference_identifier', name, location());
  }

Object = "{" _ pairs:(Pair (_ ","? _ Pair)* (_ ",")?)? _ "}" {
  const values = pairs ? [pairs[0], ...pairs[1].map(pair => pair[3])] : [];
  return makeNode('object', null, location(), values);
}

StringLiteral = QuotedString / SingleQuotedString / Heredoc

Heredoc = "<<" trim:"-"? beginMarker newline content:heredocContent endMarker {
  let finalContent = content;
  if (trim === "-") {
    // Trim leading and trailing whitespace from each line
    finalContent = content.split('\n').map(line => line.trim()).join('\n');
  }
  return makeNode('string_lit', finalContent, location());
}

beginMarker = marker:$[A-Z][A-Z0-9]* {
  heredocMarker = marker;
  return marker;
}

endMarker = newline end:$[A-Z][A-Z0-9]* &{
  const matched = heredocMarker === end;
  if (!matched) {
    error(`Expected heredoc end marker "${heredocMarker}", but found "${end}"`);
  }
  return matched;
}

heredocContent = $((!endMarker .)*) {
  return text();
}

newline = [\r\n]+

QuotedString = '"' chars:DoubleStringChar* '"' {
  return makeNode('string_lit', chars.join(''), location());
}

SingleQuotedString = "'" chars:SingleStringChar* "'" {
  return makeNode('string_lit', chars.join(''), location());
}

DoubleStringChar = [^"\\${] / EscapedChar / InterpolatedExpr
SingleStringChar = [^'\\${] / EscapedChar / InterpolatedExpr

EscapeSequence = "\\" . { return text(); }
EscapedChar = "\\" . { return text(); }
InterpolatedExpr = "${" expr:(!("}") .)* "}" { return "${" + expr.map(e => e[1]).join('') + "}"; }

Number = HexNumber / OctalNumber / DecimalNumber

HexNumber = "0x" digits:$[0-9a-fA-F]+ {
  return makeNode('number_lit', parseInt(digits, 16), location());
}

OctalNumber = "0o" digits:$[0-7]+ {
  return makeNode('number_lit', parseInt(digits, 8), location());
}

DecimalNumber = minus:"-"? int:Integer frac:Fraction? exp:Exponent? {
  return makeNode('number_lit', parseFloat(text()), location());
}

Integer = "0" / [1-9][0-9]*
Fraction = "." [0-9]+
Exponent = [eE] [+-]? [0-9]+

Boolean = val:("true" / "false") { 
  return makeNode('boolean_lit', val === 'true', location()); 
}

Array = "[" _ items:(ArrayItem (_ "," _ ArrayItem)* (_ ",")?)? _ "]" {
  const values = items ? [items[0], ...items[1].map(item => item[3])] : [];
  return makeNode('array_lit', null, location(), values);
}

ArrayItem = val:(
  StringLiteral /
  Number /
  Boolean /
  Object /
  FunctionCall /
  PrimaryExpression /
  Expression /
  Reference
) {
  return val;
}

SimpleExpression = "${" expr:(!("}") .)* "}" {
  return makeNode('interpolation', text(), location());
}

Expression = ConditionalExpression

ConditionalExpression = 
  TernaryExpression /
  LogicalExpression

ForExpression = "for" _ identifier:Identifier _ "in" _ collection:Expression _ ":" _ body:Expression {
  return makeNode('for_expression', null, location(), [
    makeIdentifierNode(identifier, location()),
    collection,
    body
  ]);
}

SplatExpression = base:PrimaryExpression _ ".*" _ attr:("." Identifier)? {
  return makeNode('splat_expression', null, location(), [
    base,
    ...(attr ? [makeIdentifierNode(attr[1], location())] : [])
  ]);
}

LogicalExpression = head:ComparisonExpression tail:(_ LogicalOperator _ ComparisonExpression)* {
  return tail.reduce((left, [_, op, __, right]) => 
    makeNode('logical_expression', op, location(), [left, right]),
    head
  );
}

UnaryLogicalExpression = "!" _ expr:Value {
  return makeNode('logical_expression', "!", location(), [expr]);
}

BinaryLogicalExpression = left:Value _ operator:("&&" / "||") _ right:Value {
  return makeNode('logical_expression', operator, location(), [left, right]);
}

TernaryExpression =
  condition:LogicalExpression _
  "?" _ trueExpr:LogicalExpression _
  ":" _ falseExpr:LogicalExpression {
    return makeNode('ternary_expression', null, location(), [condition, trueExpr, falseExpr]);
}

LogicalOperator = "&&" / "||"
ComparisonOperator = "==" / "!=" / ">=" / "<=" / ">" / "<"
AdditiveOperator = "+" / "-"
MultiplicativeOperator = "*" / "/" / "%"

ComparisonExpression = head:AdditiveExpression tail:(_ ComparisonOperator _ AdditiveExpression)* {
  return tail.reduce((left, [_, op, __, right]) =>
    makeNode('comparison_expression', op, location(), [left, right]),
    head
  );
}

AdditiveExpression = head:MultiplicativeExpression tail:(_ AdditiveOperator _ MultiplicativeExpression)* {
  return tail.reduce((left, [_, op, __, right]) =>
    makeNode('arithmetic_expression', op, location(), [left, right]),
    head
  );
}

MultiplicativeExpression = head:UnaryExpression tail:(_ MultiplicativeOperator _ UnaryExpression)* {
  return tail.reduce((left, [_, op, __, right]) =>
    makeNode('arithmetic_expression', op, location(), [left, right]),
    head
  );
}

UnaryExpression =
  LogicalNotExpression /
  NegationExpression /
  PostfixExpression

LogicalNotExpression = "!" _ expr:UnaryExpression {
  return makeNode('logical_expression', "!", location(), [expr]);
}

NegationExpression = "-" _ expr:UnaryExpression {
  return makeNode('arithmetic_expression', "-", location(), [expr]);
}

PostfixExpression = head:PrimaryExpression tail:(
  IndexAccess /
  SplatAccess /
  MemberAccess
)* {
  return tail.reduce((expr, access) => access(expr), head);
}

IndexAccess = _ "[" _ index:(Number / StringLiteral / Expression) _ "]" {
  return base => makeNode('index_expression', null, location(), [base, index]);
}

SplatAccess = _ ".*" _ attr:("." Identifier)? {
  return base => makeNode('splat_expression', null, location(), [
    base,
    ...(attr ? [makeIdentifierNode(attr[1], location())] : [])
  ]);
}


MemberAccess = _ "." _ member:Identifier {
  return base => makeNode('member_access', null, location(), [base, makeIdentifierNode(member, location())]);
}

FunctionCall = identifier:FunctionIdentifier _ "(" _ args:FunctionArgs? _ ")" {
  const argArray = args || [];
  return makeNode('function_call', null, location(), [identifier, ...argArray]);
}

FunctionArgs = first:FunctionArg rest:(_ "," _ FunctionArg?)* {
  // Filter out null/undefined args from optional trailing arguments
  const additionalArgs = rest
    .map(r => r[3])
    .filter(arg => arg !== null && arg !== undefined);
  return [first, ...additionalArgs];
}

FunctionArg = arg:(
  StringLiteral /
  Number /
  Boolean /
  Array /
  Object /
  FunctionCall /
  PrimaryExpression /
  Expression /
  Reference
) {
  return arg;
}

FunctionIdentifier = identifier:$([a-zA-Z_][a-zA-Z0-9_]*) {
  return makeNode('function_identifier', identifier, location());
}

Identifier = first:[a-zA-Z_] rest:[a-zA-Z0-9_\-.]* {
  return first + rest.join('');
}

_ = (Whitespace / Comment)*
Whitespace = [ \t\n\r]
Comment = SingleLineComment / MultiLineComment
SingleLineComment = ("#" / "//") [^\n]* "\n"?
MultiLineComment = "/*" (!"*/" .)* "*/"

TypeConstraint = 
  PrimitiveType /
  CollectionType /
  StructType /
  TupleType /
  ObjectType /
  AnyType

PrimitiveType = ("string" / "number" / "bool") {
  return makeNode('type_constraint', text(), location());
}

CollectionType = type:("list" / "set" / "map") "(" _ elementType:TypeConstraint _ ")" {
  return makeNode('collection_type', type, location(), [elementType]);
}

StructType = "object" "(" _ attrs:StructTypeAttribute* _ ")" {
  return makeNode('struct_type', null, location(), attrs);
}

StructTypeAttribute = name:Identifier _ "=" _ type:TypeConstraint _ "," _ {
  return makeNode('struct_attribute', name, location(), [type]);
}

TupleType = "tuple" "(" _ types:(TypeConstraint (_ "," _ TypeConstraint)*)? _ ")" {
  const typeList = types ? [types[0], ...types[1].map(t => t[3])] : [];
  return makeNode('tuple_type', null, location(), typeList);
}

ObjectType = "object" {
  return makeNode('type_constraint', 'object', location());
}

AnyType = "any" {
  return makeNode('type_constraint', 'any', location());
}

TypeConstructor = type:("list" / "map" / "set") "(" _ value:Value _ ")" {
  return makeNode('type_constructor', type, location(), [value]);
}

CollectionConstructor = func:("tolist" / "toset" / "tomap") "(" _ value:Value _ ")" {
  return makeNode('collection_constructor', func, location(), [value]);
}

IndexExpression = base:PrimaryExpression _ "[" _ index:(Number / StringLiteral / Expression) _ "]" {
  return makeNode('index_expression', null, location(), [base, index]);
}

InheritanceExpression = "inherit" _ "=" _ source:Value {
  return makeNode('inheritance', null, location(), [source]);
}

MetaArguments = "[" _ args:MetaArgument* _ "]" {
  return makeNode('meta_arguments', null, location(), args);
}

MetaArgument = 
  CountArg /
  ForEachArg /
  DependsOnArg /
  ProviderArg /
  LifecycleArg

CountArg = "count" _ "=" _ value:Value {
  return makeNode('meta_count', null, location(), [value]);
}

ForEachArg = "for_each" _ "=" _ value:Value {
  return makeNode('meta_for_each', null, location(), [value]);
}

DependsOnArg = "depends_on" _ "=" _ deps:Array {
  return makeNode('meta_depends_on', null, location(), [deps]);
}

ProviderArg = "provider" _ "=" _ value:Value {
  return makeNode('meta_provider', null, location(), [value]);
}

LifecycleArg = "lifecycle" _ "{" _ rules:LifecycleRule* _ "}" {
  return makeNode('meta_lifecycle', null, location(), rules);
}

LifecycleRule = (
  "create_before_destroy" _ "=" _ Boolean /
  "prevent_destroy" _ "=" _ Boolean /
  "ignore_changes" _ "=" _ Array
) {
  return makeNode('lifecycle_rule', null, location(), []);
}

ValidationBlock = "validation" _ "{" _
  "condition" _ "=" _ condition:Expression _
  "error_message" _ "=" _ message:StringLiteral _
"}" {
  return makeNode('validation', null, location(), [
    makeNode('condition', null, location(), [condition]),
    makeNode('error_message', null, location(), [message])
  ]);
}