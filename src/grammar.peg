{
  let debugEnabled = false;
  let heredocMarker = null;
  let nextId = 1;

  function debugLog(rule, text, pos, context = {}) {
    if (debugEnabled) {
      let preview = '';
      // Check if text is a string
      if (typeof text == 'string') {
        preview = text?.substring(Math.max(0, pos - 20), pos + 20)
          .replace(/\n/g, '\\n');
      } else {
        if (typeof text == 'function') {
          preview = text().substring(Math.max(0, pos - 20), pos + 20);
        } else {
          preview = '';
          console.log('text is not a function, it is a ' + typeof text);
        }
      }
      const positionMarker = 'â†’';
      const markerPos = Math.min(20, pos);

      const contextInfo = Object.entries(context)
        .map(([key, value]) => `${key}: ${JSON.stringify(value)}`)
        .join(', ');

      console.log(
        `[${rule}] at pos ${pos}\n` +
        `Context: ${contextInfo}\n` +
        `${preview.slice(0, markerPos)}${positionMarker}${preview.slice(markerPos)}\n` +
        `${' '.repeat(markerPos)}${positionMarker}\n`
      );
    }
  }

  function getNextId() {
    return nextId++;
  }

  function makeNode(type, value, location, children = []) {
    const node = {
      id: getNextId(),
      type,
      ...(value !== null && { value }),
      location,
      ...(children.length > 0 && { children })
    };

    if (debugEnabled) {
      console.log('Created Node:', JSON.stringify(node, null, 2));
    }

    return node;
  }

  function makeIdentifierNode(name, location) {
    return makeNode('identifier', name, location);
  }
}

Start = _ statements:Statement* _ {
  debugLog('Start', text, location().start.offset, { statementsCount: statements.length });
  return makeNode('root', null, location(), statements);
}

Statement = statement:(RootAssignment / Block) _ { return statement; }

RootAssignment = _ name:RootAssignmentIdentifier _ "=" _ value:(RootValue / Boolean / StringLiteral) {
  return makeNode('assignment', name.value, location(), [name, value]);
}

RootValue = val:(Block / RootObject / Array / TernaryExpression / ComparisonExpression / FunctionCall / Expression) {
  return val;
}

Block = _ name:BlockIdentifier _ params:BlockParameter* _ "{" _ items:(Pair / ParameterizedBlock / Block)* _ "}" {
  return makeNode('block', name.value, location(), [name, ...params, ...items]);
}

ParameterizedBlock = name:BlockIdentifier _ param:StringLiteral _ "{" _ items:(Pair / Block)* _ "}" {
  const paramNode = makeNode('parameter', param.value, param.location, [param]);
  return makeNode('block', name.value, location(), [name, paramNode, ...items]);
}

BlockIdentifier = name:$([a-zA-Z_][a-zA-Z0-9_\-.*]*) {
  return makeNode('block_identifier', name, location());
}

BlockParameter = _ param:StringLiteral {
  return makeNode('parameter', param.value, location(), [param]);
}

RootAssignmentIdentifier
  = name:$([a-zA-Z_][a-zA-Z0-9_\-.]*) {
    return makeNode('root_assignment_identifier', name, location());
  }

Pair = key:AttributeIdentifier _ "=" _ value:Value {
  return makeNode('attribute', key.value, location(), [key, value]);
}

AttributeIdentifier
  = QuotedAttributeIdentifier / UnquotedAttributeIdentifier

QuotedAttributeIdentifier
  = str:StringLiteral {
    return makeNode('attribute_identifier', str.value, location(), [], { quoted: true });
  }

UnquotedAttributeIdentifier
  = name:$([a-zA-Z_][a-zA-Z0-9_\-.]*) {
    return makeNode('attribute_identifier', name, location(), [], { quoted: false });
  }

RootObject = "{" _ pairs:(Pair (_ ","? _ Pair)* (_ ",")?)? _ "}" {
  const values = pairs ? [pairs[0], ...pairs[1].map(pair => pair[3])] : [];
  return makeNode('object', null, location(), values);
}

Value = val:(TernaryExpression / ComparisonExpression / StringLiteral / Number / Boolean / Array / Object / FunctionCall / Expression / Reference) _ {
  return val;
}

Reference = !FunctionCall head:ReferenceIdentifier tail:("." ReferenceIdentifier)* {
  return makeNode('reference', head.value + tail.map(t => "." + t[1].value).join(''), location());
}

ReferenceIdentifier
  = name:$([a-zA-Z_][a-zA-Z0-9_\-.]*) {
    return makeNode('reference_identifier', name, location());
  }

Object = "{" _ pairs:(Pair (_ ","? _ Pair)* (_ ",")?)? _ "}" {
  const values = pairs ? [pairs[0], ...pairs[1].map(pair => pair[3])] : [];
  return makeNode('object', null, location(), values);
}

StringLiteral = QuotedString / SingleQuotedString / Heredoc

Heredoc = "<<"? beginMarker newline content:heredocContent endMarker {
  return makeNode('string_lit', content, location());
}

beginMarker = marker:$[A-Z][A-Z0-9]* {
  heredocMarker = marker;
  return marker;
}

endMarker = newline end:$[A-Z][A-Z0-9]* &{
  const matched = heredocMarker === end;
  if (!matched) {
    error(`Expected heredoc end marker "${heredocMarker}", but found "${end}"`);
  }
  return matched;
}

heredocContent = $((!endMarker .)*) {
  return text();
}

newline = [\r\n]+

QuotedString = '"' chars:DoubleStringChar* '"' {
  return makeNode('string_lit', chars.join(''), location());
}

SingleQuotedString = "'" chars:SingleStringChar* "'" {
  return makeNode('string_lit', chars.join(''), location());
}

DoubleStringChar = [^"\\${] / EscapedChar / InterpolatedExpr
SingleStringChar = [^'\\${] / EscapedChar / InterpolatedExpr

EscapeSequence = "\\" . { return text(); }
EscapedChar = "\\" . { return text(); }
InterpolatedExpr = "${" expr:(!("}") .)* "}" { return "${" + expr.map(e => e[1]).join('') + "}"; }

Number = minus:"-"? int:Integer frac:Fraction? exp:Exponent? {
  return makeNode('number_lit', parseFloat(text()), location());
}

Integer = "0" / [1-9][0-9]*
Fraction = "." [0-9]+
Exponent = [eE] [+-]? [0-9]+

Boolean = val:("true" / "false") { 
  return makeNode('boolean_lit', val === 'true', location()); 
}

Array = "[" _ items:(ArrayItem (_ "," _ ArrayItem)* (_ ",")?)? _ "]" {
  const values = items ? [items[0], ...items[1].map(item => item[3])] : [];
  return makeNode('array_lit', null, location(), values);
}

ArrayItem = val:(StringLiteral / Number / Boolean / Object / FunctionCall / Expression / Reference) {
  return val;
}

SimpleExpression = "${" expr:(!("}") .)* "}" {
  return makeNode('interpolation', text(), location());
}
Expression = TernaryExpression / SimpleExpression / ComparisonExpression

TernaryExpression = condition:(ComparisonExpression / FunctionCall) _ "?" _ trueExpr:(Boolean / Value) _ ":" _ falseExpr:(Boolean / Value) {
  return makeNode('ternary_expression', null, location(), [condition, trueExpr, falseExpr]);
}

ComparisonExpression = left:(FunctionCall / StringLiteral / SimpleExpression) _ "==" _ right:(StringLiteral / FunctionCall / SimpleExpression) {
  return makeNode('comparison_expression', null, location(), [left, right]);
}

FunctionCall = identifier:FunctionIdentifier _ "(" _ args:FunctionArgs? _ ")" {
  const argArray = args || [];
  return makeNode('function_call', null, location(), [identifier, ...argArray]);
}

FunctionArgs = first:FunctionArg rest:(_ "," _ FunctionArg?)* {
  // Filter out null/undefined args from optional trailing arguments
  const additionalArgs = rest
    .map(r => r[3])
    .filter(arg => arg !== null && arg !== undefined);
  return [first, ...additionalArgs];
}

FunctionArg = arg:(
  StringLiteral /
  Number /
  Boolean /
  Array /
  Object /
  FunctionCall /
  Reference /
  Expression
) {
  return arg;
}

FunctionIdentifier = identifier:$([a-zA-Z_][a-zA-Z0-9_]*) {
  return makeNode('function_identifier', identifier, location());
}

Identifier = first:[a-zA-Z_] rest:[a-zA-Z0-9_\-.]* {
  return first + rest.join('');
}

_ = (Whitespace / Comment)*
Whitespace = [ \t\n\r]
Comment = SingleLineComment / MultiLineComment
SingleLineComment = ("#" / "//") [^\n]* "\n"?
MultiLineComment = "/*" (!"*/" .)* "*/"