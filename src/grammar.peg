{
  let debugEnabled = false;
  function debugLog(rule, text, pos, context = {}) {
    if (debugEnabled) {
      let preview = '';
      // Check if text is a string
      if (typeof text == 'string') {
        preview = text?.substring(Math.max(0, pos - 20), pos + 20)
          .replace(/\n/g, '\\n');
      } else {
        if (typeof text == 'function') {
          preview = text().substring(Math.max(0, pos - 20), pos + 20);
        } else {
          preview = '';
          console.log('text is not a function, it is a ' + typeof text);
        }
      }
      const positionMarker = 'â†’';
      const markerPos = Math.min(20, pos);

      const contextInfo = Object.entries(context)
        .map(([key, value]) => `${key}: ${JSON.stringify(value)}`)
        .join(', ');

      console.log(
        `[${rule}] at pos ${pos}\n` +
        `Context: ${contextInfo}\n` +
        `${preview.slice(0, markerPos)}${positionMarker}${preview.slice(markerPos)}\n` +
        `${' '.repeat(markerPos)}${positionMarker}\n`
      );
    }
  }

  let nextId = 1;

  function getNextId() {
    return nextId++;
  }

  // Only include non-empty children array
  function makeNode(type, value, location, children = []) {
    const node = {
      id: getNextId(),
      type,
      ...(value !== null && { value }),
      location,
      ...(children.length > 0 && { children })
    };

    if (debugEnabled) {
      console.log('Created Node:', JSON.stringify(node, null, 2));
    }

    return node;
  }

  function makeIdentifierNode(name, location) {
    return makeNode('identifier', name, location);
  }
}

// Starting rule for Terragrunt configuration
Start = _ statements:Statement* _ {
  debugLog('Start', text, location().start.offset, { statementsCount: statements.length });
  return makeNode('root', null, location(), statements);
}

Statement = statement:(Block / RootAssignment) _ { return statement; }

// Block identifier with proper location
Block = _ name:BlockIdentifier _ params:BlockParameter* _ "{" _ items:(Pair / Block)* _ "}" {
  return makeNode('block', name.value, location(), [name, ...params, ...items]);
}

BlockIdentifier
  = name:$([a-zA-Z_][a-zA-Z0-9_\-.*]*) {
    return makeNode('block_identifier', name, location());
  }

BlockParameter = _ param:StringLiteral {
  return makeNode('parameter', param.value, location(), [param]);
}

RootAssignment = _ name:RootAssignmentIdentifier _ "=" _ value:RootValue {
  return makeNode('assignment', name.value, location(), [name, value]);
}

RootAssignmentIdentifier
  = name:$([a-zA-Z_][a-zA-Z0-9_\-.]*) {
    return makeNode('root_assignment_identifier', name, location());
  }

Pair = key:AttributeIdentifier _ "=" _ value:Value {
  return makeNode('attribute', key.value, location(), [key, value]);
}

AttributeIdentifier
  = QuotedAttributeIdentifier / UnquotedAttributeIdentifier

QuotedAttributeIdentifier
  = str:StringLiteral {
    return makeNode('attribute_identifier', str.value, location(), [], { quoted: true });
  }

UnquotedAttributeIdentifier
  = name:$([a-zA-Z_][a-zA-Z0-9_\-.]*) {
    return makeNode('attribute_identifier', name, location(), [], { quoted: false });
  }

RootValue = val:(RootObject / Block / FunctionCall / Expression) {
  return val;
}

RootObject = "{" _ pairs:(Pair (_ ","? _ Pair)* (_ ",")?)? _ "}" {
  const values = pairs ? [pairs[0], ...pairs[1].map(pair => pair[3])] : [];
  return makeNode('object', null, location(), values);
}

Value = val:(StringLiteral / Number / Boolean / Array / Object / FunctionCall / Expression / Reference / HereDoc) _ {
  return val;
}

HereDoc
  = "<<" _ identifier:HereDocIdentifier _ "\n"
    content:HereDocContent
    end:HereDocEnd {
    return makeNode('heredoc', content, location());
  }

HereDocIdentifier
  = chars:[A-Z]+ { return chars.join(''); }

HereDocContent
  = chars:(!HereDocEnd .)* { return chars.map(c => c[1]).join(''); }

HereDocEnd
  = identifier:HereDocIdentifier _ { return identifier; }

Reference = !FunctionCall head:ReferenceIdentifier tail:("." ReferenceIdentifier)* {
  return makeNode('reference', head.value + tail.map(t => "." + t[1].value).join(''), location());
}

ReferenceIdentifier
  = name:$([a-zA-Z_][a-zA-Z0-9_\-.]*) {
    return makeNode('reference_identifier', name, location());
  }

Object = "{" _ pairs:(Pair (_ ","? _ Pair)* (_ ",")?)? _ "}" {
  const values = pairs ? [pairs[0], ...pairs[1].map(pair => pair[3])] : [];
  return makeNode('object', null, location(), values);
}

StringLiteral = QuotedString / SingleQuotedString

QuotedString = '"' chars:DoubleStringChar* '"' {
  return makeNode('string_lit', chars.join(''), location());
}

SingleQuotedString = "'" chars:SingleStringChar* "'" {
  return makeNode('string_lit', chars.join(''), location());
}

DoubleStringChar = [^"\\${] / EscapedChar / InterpolatedExpr
SingleStringChar = [^'\\${] / EscapedChar / InterpolatedExpr

EscapeSequence = "\\" . { return text(); }
EscapedChar = "\\" . { return text(); }
InterpolatedExpr = "${" expr:(!("}") .)* "}" { return "${" + expr.map(e => e[1]).join('') + "}"; }

Number = minus:"-"? int:Integer frac:Fraction? exp:Exponent? {
  return makeNode('number_lit', parseFloat(text()), location());
}

Integer = "0" / [1-9][0-9]*
Fraction = "." [0-9]+
Exponent = [eE] [+-]? [0-9]+

Boolean = ("true" / "false") { return makeNode('boolean_lit', text() === 'true', location()); }

Array = "[" _ items:(ArrayItem (_ "," _ ArrayItem)* (_ ",")?)? _ "]" {
  const values = items ? [items[0], ...items[1].map(item => item[3])] : [];
  return makeNode('array_lit', null, location(), values);
}

ArrayItem = val:(StringLiteral / Number / Boolean / Object / FunctionCall / Expression / Reference) {
  return val;
}

Expression = "${" expr:(!("}") .)* "}" {
  return makeNode('interpolation', text(), location());
}

FunctionCall = name:FunctionIdentifier _ "(" _ first:FunctionArg? rest:(_ "," _ FunctionArg)* _ ")" {
  const args = first ? [first].concat(rest.map(r => r[3])) : [];
  return makeNode('function_call', text(), location(), [name, ...args]);
}

FunctionIdentifier
  = name:$([a-zA-Z_][a-zA-Z0-9_\-.]*) {
    return makeNode('function_identifier', name, location());
  }

FunctionArg = arg:(StringLiteral / Number / Boolean / Array / Object / FunctionCall / Reference) {
  return arg;
}

Identifier = first:[a-zA-Z_] rest:[a-zA-Z0-9_\-.]* {
  return first + rest.join('');
}

_ = (Whitespace / Comment)*
Whitespace = [ \t\n\r]
Comment = SingleLineComment / MultiLineComment
SingleLineComment = ("#" / "//") [^\n]* "\n"?
MultiLineComment = "/*" (!"*/" .)* "*/"