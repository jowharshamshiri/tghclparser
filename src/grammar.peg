{
  let nextId = 1;
  
  function getNextId() {
    return nextId++;
  }

  function makeNode(type, value, location, children = []) {
    return {
      id: getNextId(),
      type,
      value,
      location,
      ...(children.length > 0 && { children })
    };
  }

  function makeIdentifierNode(name, location) {
    return makeNode('attribute_identifier', name, location);
  }
}

// Starting rule for Terragrunt configuration
Start
  = _ statements:Statement* _ { 
    return makeNode('root', statements, location());
  }

Statement
  = _ statement:(Block / RootAssignment) _ {
    return statement;
  }

Block
  = name:BlockIdentifier _ "{" _ 
    pairs:(Pair*) 
    _ "}" {
      return makeNode('block', name.value, location(), [name, ...pairs].filter(Boolean));
    }

BlockIdentifier
  = name:Identifier {
    return makeIdentifierNode(name, location());
  }

RootAssignment
  = key:AssignmentIdentifier _ "=" _ value:RootValue {
    return makeNode('assignment', key.value, location(), [key, value]);
  }

AssignmentIdentifier
  = name:Identifier {
    return makeIdentifierNode(name, location());
  }

Pair
  = _ key:AttributeIdentifier _ "=" _ value:Value _ {
    return makeNode('attribute', key.value, location(), [key, value]);
  }

AttributeIdentifier
  = name:Identifier {
    return makeIdentifierNode(name, location());
  }

RootValue
  = val:(RootObject / Expression) {
    return val;
  }

RootObject
  = "{" _ pairs:Pair* _ "}" {
    return makeNode('object', null, location(), pairs);
  }

Value
  = val:(StringLiteral / Number / Boolean / Array / Object / Expression) {
    return val;
  }

Object
  = "{" _ pairs:Pair* _ "}" {
    return makeNode('object', null, location(), pairs);
  }

StringLiteral
  = '"' chars:StringChar* '"' {
    return makeNode('string_lit', chars.join(''), location());
  }
  / "'" chars:SingleQuoteChar* "'" {
    return makeNode('string_lit', chars.join(''), location());
  }

StringChar
  = [^"\\]
  / "\\" char:["\\/bfnrt] { return eval('"\\' + char + '"'); }

SingleQuoteChar
  = [^'\\]
  / "\\" char:. { return char; }

Number
  = minus:"-"? int:Integer frac:Fraction? exp:Exponent? {
    return makeNode(
      'number_lit', 
      parseFloat((minus || '') + int + (frac || '') + (exp || '')),
      location()
    );
  }

Integer
  = "0"
  / [1-9] [0-9]*

Fraction
  = "." [0-9]+

Exponent
  = [eE] [+-]? [0-9]+

Boolean
  = "true" { return makeNode('boolean_lit', true, location()); }
  / "false" { return makeNode('boolean_lit', false, location()); }

Array
  = "[" _ items:(Value ( _ "," _ Value)*)? _ "]" {
    const values = items 
      ? [items[0]].concat(items[1].map(item => item[3]))
      : [];
    return makeNode('array_lit', null, location(), values);
  }

Expression
  = "${" _ chars:ExpressionChar+ _ "}" { 
    return makeNode('interpolation', "${" + chars.join('') + "}", location());
  }
  / FunctionCall

ExpressionChar
  = [^}]

FunctionCall
  = name:Identifier _ "(" _ args:FunctionArgs? _ ")" {
    const fnName = makeIdentifierNode(name, location());
    const fnVal = `${name}(${args ? args.join(', ') : ''})`;
    return makeNode('function_call', fnVal, location(), [fnName]);
  }

FunctionArgs
  = arg:Value rest:( _ "," _ Value)* {
    return [arg].concat(rest.map(r => r[3]));
  }

Identifier
  = chars:IdentifierChar+ {
    return chars.join('');
  }

IdentifierChar
  = [a-zA-Z0-9_-]

// Whitespace and comments
_
  = (Whitespace / Comment)*

Whitespace
  = [ \t\n\r]

Comment
  = SingleLineComment
  / MultiLineComment

SingleLineComment
  = "//" [^\n]*
  / "#" [^\n]*

MultiLineComment
  = "/*" (!"*/" .)* "*/"