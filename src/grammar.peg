{
  let debugEnabled = true;
  function debugLog(rule, text, pos, context = {}) {
    if (debugEnabled) {
	  let preview = '';
	  //check text is a string
	  if (typeof text == 'string') {
          preview = text?.substring(Math.max(0, pos - 20), pos + 20)
        .replace(/\n/g, '\\n');
	  }else{
		if (typeof text == 'function') {
			preview = text().substring(Math.max(0, pos - 20), pos + 20)
		}else{
			preview = ''
			console.log('text is not a function, it is a ' + typeof text);
		}
	  }
      const positionMarker = 'â†’';
      const markerPos = Math.min(20, pos);
      
      const contextInfo = Object.entries(context)
        .map(([key, value]) => `${key}: ${JSON.stringify(value)}`)
        .join(', ');
        
      console.log(
        `[${rule}] at pos ${pos}\n` +
        `Context: ${contextInfo}\n` +
        `${preview.slice(0, markerPos)}${positionMarker}${preview.slice(markerPos)}\n` +
        `${' '.repeat(markerPos)}${positionMarker}\n`
      );
    }
  }

  let nextId = 1;
  
  function getNextId() {
    return nextId++;
  }

  // Only include non-empty children array
  function makeNode(type, value, location, children = []) {
    const node = {
      id: getNextId(),
      type,
      ...(value !== null && { value }),
      location,
      ...(children.length > 0 && { children })
    };
    
    if (debugEnabled) {
      console.log('Created Node:', JSON.stringify(node, null, 2));
    }
    
    return node;
  }

  function makeIdentifierNode(name, location) {
    return makeNode('identifier', name, location);
  }
}

// Starting rule for Terragrunt configuration
Start = _ statements:Statement* _ {
  debugLog('Start', text, location().start.offset, {statementsCount: statements.length});
  return makeNode('root', null, location(), statements);
}

Statement = statement:(Block / RootAssignment) _ { return statement; }

Block = _ name:Identifier _ params:BlockParameter* _ "{" _ items:(Pair / Block)* _ "}" {
  return makeNode('block', name, location(), [makeIdentifierNode(name, location()), ...params, ...items]);
}

BlockInRootAssignment = name:Identifier params:BlockParameter* _ "{" _ items:(Pair / Block)* _ "}" {
  return makeNode('block', name, location(), [makeIdentifierNode(name, location()), ...params, ...items]);
}

BlockParameter = _ param:StringLiteral {
  return makeNode('parameter', param.value, location(), [param]);
}

BlockIdentifier
  = name:Identifier {
    return makeIdentifierNode(name, location());
  }

RootAssignment = _ name:Identifier _ "=" _ value:RootValue {
  return makeNode('assignment', name, location(), [makeIdentifierNode(name, location()), value]);
}


AssignmentIdentifier
  = name:Identifier {
    return makeIdentifierNode(name, location());
  }
  
Pair = key:Identifier _ "=" _ value:Value {
  return makeNode('attribute', key, location(), [makeIdentifierNode(key, location()), value]);
}

AttributeIdentifier
  = name:Identifier {
    return makeIdentifierNode(name, location());
  }

RootValue = val:(RootObject / BlockInRootAssignment / FunctionCall / Expression) {
  return val;
}

RootObject = "{" _ pairs:Pair* _ "}" { 
  return makeNode('object', null, location(), pairs); 
}

Value = val:(StringLiteral / Number / Boolean / Array / Object / FunctionCall / Expression / Reference / HereDoc) _ {
  return val;
}

HereDoc
  = "<<" _ identifier:HereDocIdentifier _ "\n"
    content:HereDocContent
    end:HereDocEnd {
    return makeNode('heredoc', content, location());
  }

HereDocIdentifier
  = chars:[A-Z]+ { return chars.join(''); }

HereDocContent
  = chars:(!HereDocEnd .)* { return chars.map(c => c[1]).join(''); }

HereDocEnd
  = identifier:HereDocIdentifier _ { return identifier; }

Reference = !FunctionCall head:Identifier tail:("." Identifier)* {
  return makeNode('reference', head + tail.map(t => "." + t[1]).join(''), location());
}

Object = "{" _ pairs:Pair* _ "}" { 
  return makeNode('object', null, location(), pairs); 
}

StringLiteral = '"' chars:DoubleStringChar* '"' { return makeNode('string_lit', chars.join(''), location()); }
  / "'" chars:SingleStringChar* "'" { return makeNode('string_lit', chars.join(''), location()); }

DoubleStringChar = [^"\\${] / "${" expr:(!("}") .)* "}" { return "${" + expr.map(e => e[1]).join('') + "}"; } / EscapeSequence
SingleStringChar = [^'\\${] / "${" expr:(!("}") .)* "}" { return "${" + expr.map(e => e[1]).join('') + "}"; } / EscapeSequence

EscapeSequence = "\\" . { return text(); }

Number = minus:"-"? int:Integer frac:Fraction? exp:Exponent? {
  return makeNode('number_lit', parseFloat(text()), location());
}

Integer = "0" / [1-9][0-9]*
Fraction = "." [0-9]+
Exponent = [eE] [+-]? [0-9]+

Boolean = ("true" / "false") { return makeNode('boolean_lit', text() === 'true', location()); }

Array = "[" _ items:(Value (_ "," _ Value)*)? _ "]" {
  const values = items ? [items[0], ...items[1].map(i => i[3])] : [];
  return makeNode('array_lit', null, location(), values);
}

Expression = "${" expr:(!("}") .)* "}" {
  return makeNode('interpolation', "${" + expr.map(e => e[1]).join('') + "}", location());
}

ExpressionChar
  = [^}]

FunctionCall = name:Identifier _ "(" _ first:FunctionArg? rest:(_ "," _ FunctionArg)* _ ")" {
  const args = first ? [first].concat(rest.map(r => r[3])) : [];
  return makeNode('function_call', text(), location(), [makeIdentifierNode(name, location()), ...args]);
}

FunctionArg = arg:(StringLiteral / Number / Boolean / Array / Object / FunctionCall / Reference) {
  return arg;
}

Identifier = first:[a-zA-Z_] rest:[a-zA-Z0-9_\-.]* { return first + rest.join(''); }

IdentifierChar
  = [a-zA-Z0-9_\-.]

_
_ = (Whitespace / Comment)*
Whitespace = [ \t\n\r]
Comment = SingleLineComment / MultiLineComment
SingleLineComment = ("#" / "//") [^\n]* "\n"?
MultiLineComment = "/*" (!"*/" .)* "*/"